//Load required classes.
const { Sessions, Servers } = require('alta-jsapi');
const jsapi = require("alta-jsapi");
const { WebsocketBot } = require('att-bot-core');
const { BasicWrapper, Connection } = require('att-websockets');
const Discord = require('discord.js');
const {Client, RichEmbed} = require('discord.js');
const moment = require('moment');
const sha512 = require('crypto-js/sha512');
const fs = require('fs');

//Local classes
const Player = require('./src/player.js');
const Subscriptions = require('./src/subscriptions.js');

//Load information from credentials and config
const { username, password, botToken } = require("./credentials");
const { targetServer, showAllServers, discordPrefix, discordChannels, discordRoles } = require("./config");

//NeDB
var Datastore = require('nedb');
var players = new Datastore({ filename : 'data/players.db', autoload: true });
var kills = new Datastore({ filename : 'data/playerkills.db', autoload: true });
var chunkHistory = new Datastore({ filename : 'data/chunkhistory.db', autoload: true });
players.ensureIndex({ fieldName: 'id', unique: 'true' });
players.persistence.setAutocompactionInterval( 129600 );

var connectInterval = 30000; // milliseconds
var serverPingInterval = 15000; // ms
var subscriptionConnectInterval = 10000; //ms
var RefreshSub = 300000; //ms
var serverConnectedState = false;
var subscriptionsActive = false;
var botConnection = {};
var pendingCommandList = [];

//Some utility helper functions and prototypes
function ts()
{ 
    return "["+ moment().format("YYYY/MM/DD HH:MM:SS") +"] " 
}

function strrep( str, n )
{
    if ( n < 1 ) return '';
    var result = str;
    while( n-- > 0 )
    {
        result += str;
    }
    return result;
}

function convertPassToHash( username, password, botToken )
{
    // The SHA512 hash generated by crypto-js/sha512 will be 128 characters
    if ( password.length !== 128 )
    {
        console.log( "Plaintext password encountered, converting to SHA512 hash for permanent storage" );
        newPass = sha512( password ).toString();
        newFile = { "username" : username, "password" : newPass, "botToken": botToken };
        fs.writeFile('./credentials.json', JSON.stringify( newFile, null, 4 ), function( err ) {
            if ( err )
            {
                console.log( err );
            } else {
                console.log( "New credentials.json saved" );
            }
        });
        password = newPass;
    }
    return password;
}


//Command list
const commands = {
    'ping': (message) =>
    {
        message.channel.send("pong");
    },
    'where': (message, args) =>
    {
        while ( args.length && args[0].toLowerCase() === "is" )
        {
            argv = args.shift();
        }

        var username = args.join(' ');
        players.findOne({ username: username }, function( err, player ) {
            if ( err )
            {
                console.log( err );
            } else if ( !!player && player.lastChunk !== undefined ) {
                message.channel.send( '```'+ username +" was last seen at "+ player.lastChunk +'```');
            } else {
                message.channel.send( '```'+ "No location known for "+ username +'```' );
            }
        });
    },
    'player' : async function ( message, args )
    {
        switch( args.shift() )
        {
            case 'path':
                // Return known history of player movements
                var username = args.join(' ');
                players.findOne({ username: username }, function( err, player ) {
                    if ( err ) 
                    {
                        message.channel.send('```'+ "No player data found for "+ username +'```');
                    } else {
                        if ( !!player )
                        {
                            chunkHistory.find({ player: player.id }).sort({ ts: -1 }).exec( function ( err, chunklist ) {
                                if ( err )
                                {
                                    console.log( err );
                                } else if ( !!chunklist ) {
                                    let limit = 20;
                                    var response  = '| Path History for '+ username +"\n";
                                        response += '|------------------'+ strrep('-', username.length+1) +"\n";
                                    if ( chunklist.length < limit ) { limit = chunklist.length; }
                                    for ( var i = 0; i < limit ; i++ ) {
                                        var elem = chunklist[i];
                                        response += "|["+ moment( elem.ts ).format( "YYYY/MM/DD HH:mm:ss" ) +"] "+ elem.chunk +"\n";
                                    }
                                    message.channel.send('```'+ response +'```');
                                } else {
                                    message.channel.send('```'+ "No path data found for "+ username +'```');
                                }
                            });
                        } else {
                            message.channel.send('```'+ "No player found for "+ username +'```');
                        }
                    }
                });
            break;
            
        }
    },
    'players': async function (message, args)
    {
        var servers = await Servers.getOnline();
        var listTable = '';

        while ( args.length && ( args[0].toLowerCase() === "online" || args[0].toLowerCase() === "in" || args[0].toLowerCase() === "on" ) )
        {
            args.shift();
        }

        var mustMatch = args.join(' ');

        for( var i in servers )
        {
            var pOnline = servers[i].online_players;
            if ( pOnline.length <= 0 && !mustMatch ) 
            {
                continue
            }

            if ( !showAllServers && !targetServer.includes( servers[i].id ) )
            {
                continue;
            }
            
            if ( mustMatch )
            {
                var re = new RegExp( mustMatch, 'ig' );
                if ( !servers[i].name.match( re ) )
                {
                    continue;
                }
            }
                       
            listTable += "| "+ servers[i].name + "\n";
            listTable += "|"+ strrep('-', (servers[i].name.length + 1)) +"\n";     

            if ( pOnline.length <= 0 )
            {
                listTable += "| No players online\n"
            } else {
                for( var n in pOnline )
                {
                    listTable += "| "+ pOnline[n].username +"\n";
                }
            }

            listTable += "\n";
        }

        if ( listTable === '' )
        {
            if ( mustMatch )
            {
                message.channel.send('```No server found matching "'+ mustMatch +'"```');
            } else {
                message.channel.send('```No players were found online```');
            }
        } else {
            message.channel.send('```'+ listTable +'```');
        }
    },
    'zone': async function (message, args)
    {
        switch( args.shift() )
        {
            case 'history':
                var chunkName = args.join(' ');
                players.find({}, function( err, playerList ) {
                    chunkHistory.find({ chunk: chunkName }).sort({ ts: -1 }).exec( function( err, chunklist ) {
                        if ( err )
                        {
                            console.log( err );
                        } else if ( !chunklist ) {
                            message.channel.send('```'+ "No history for zone '"+ chunkName +"'"+ '```');
                        } else {
                            var response  = "| Players who have recently visited zone '"+ chunkName +"'\n";
                                response += "|--------------------------------"+ strrep( '-', chunkName.length ) +"-\n";
                            let limit = 1500;
                            if ( chunklist.length < limit ) { limit = chunklist.length; }
                            for ( var i = 0; i < limit; i++ ) {
                                ichunk = chunklist[i];
                                if ( ++i > 10 ) { }
                                player = playerList.find( x => x.id === ichunk.player );
                                response += "|["+ moment( ichunk.ts ).format("YYYY/MM/DD HH:mm:ss") +"] "+ player.username +"\n";
                                if ( response.length > 1900 ) {
                                    message.channel.send('```'+ response +'```');
                                    response = "|--------------------------------"+ strrep( '-', chunkName.length ) +"-\n";
                                }                        
                            };
                            message.channel.send('```'+ response +'```');   
                        }
                    });
                });
            break;
        }
    },
    'coinbank': (message, args) =>
    {
        if ( message.member.roles.some( x => discordRoles.admin.includes( x.id ) )){
        players.findOne({ username: args[0] }, function(err, docs) {
            try{
            message.channel.send( '```'+ "User "+ args[0] + " has "  + docs.Bank +'```' );
        }
        catch{
            message.channel.send( '```'+ "User "+ args[0] + " not found " +'```' );
        }
        });
    }else{
        message.channel.send( '```'+ "No" +'```' );
    }
    },
    'playermessage': (message, args) =>
    {
        if ( message.member.roles.some( x => discordRoles.admin.includes( x.id ) )){
        //args[0] = player
        //args[1] = message
        //args[2] = seconds
        botConnection.wrapper.send("player message " + args[0] + " " + "'" + args[1] + "'" + " " + args[2]);
        message.channel.send( '```'+ "Message Sent" +'```' );
        }else{
            message.channel.send( '```'+ "No" +'```' );
        }
    },
    'help': (message) =>
    {
        if ( message.member.roles.some( x => discordRoles.admin.includes( x.id ) )){
            const Embed = new RichEmbed()
            .setColor('#00FF00')
            .setTitle('Commands')
            .addField('!ping', 'Replys with pong to indicate bot is online', false )
            .addField('!where (playername)', 'Replys with the current location of a player', false )
            .addField('!player path (playername)', 'Replys with a list of every chunk the player has entered', false )
            .addField('!players', 'Replys with current online server', false )
            .addField('!zone history (Chunk)', 'Replys with a list of every player to enter the chunk', false )
            .addField('!coinbank (playername)', 'Checks the current balance of the players current ingame ATM coin count', false )
            .addField('!playermessage (playername) (Message in quotes) (seconds)', 'Sends an ingame message to a player', false )
            .addField('!help', 'Replys with a list of commands', false )
            message.channel.send(Embed);
        }else{
            const Embed = new RichEmbed()
            .setColor('#00FF00')
            .setTitle('Commands')
            .addField('!ping', 'Replys with pong to indicate bot is online', false )
            .addField('!where (playername)', 'Replys with the current location of a player', false )
            .addField('!players', 'Replys with current online server', false )
            .addField('!help', 'Replys with a list of commands', false )
            message.channel.send(Embed);
        }
    }
}

function splitArgs( args )
{
    let spaceChars = '#s#';
    // If an exact match of the space character exists in the string, make it more unique
    while( args.indexOf( spaceChars ) > -1 ) { spaceChars += '|'; }

    // replace spaces which are inside quotes with the spaceChar placeholder
    let mangleargs = args.replace( /[“"]([^“^"]*)[“"]?/g, ( match, cap ) => {
        return cap.replace(/\s/g, spaceChars );
    });

    // split the padded string on actual spaces
    let newargs = mangleargs.split( /\ +/ );

    // replace the spaceChar in any matching elements with actual spaces
    let reg = new RegExp( spaceChars, 'g' );
    let argarr = newargs.map( ( x ) => { return x.replace( reg, ' ' ); });

    return argarr;
}

async function sleep( ms )
{
    await new Promise( resolve => setTimeout( resolve, ms ))
}

async function subscribeTo( subscription, callback )
{
    if ( serverConnectedState && ( typeof( botConnection.wrapper ) !== undefined ) )
    {        
        let state = await botConnection.wrapper.subscribe( subscription, callback )
        if (( typeof( state.Result ) == undefined ) || state.Result != 'Success' )
        {
            botConnection.wrapper.unsubscribe( subscription, callback )
            console.log( "Subscription to "+ subscription +" failed: ", state )
            setTimeout( function() { subscribeTo( subscription, callback ) }, subscriptionConnectInterval )
        } else {
            subscriptionsActive = true;
        }
    }
}

//Run the program
main();

async function main()
{
    console.log( ts() + "bot is starting" );

    // Convert the password to a hash if necessary
    var mpassword = convertPassToHash( username, password, botToken );
    // Players in database
    //players.find({}).exec( function( err, docs ) { console.log( docs ); });

    //Connect to discord
    const discord = new Discord.Client({
        disableEveryone: true,
        messageCacheMaxSize: 150,
        messageCacheLifetime: 240,
        messageSweepInterval: 300,
      });
    await new Promise( resolve =>
    {
        discord.on('ready', resolve);
        discord.login(botToken);
    });
    //Discord command and message management (todo: move to own lib)
    discord.on('message', message =>
    {
        if ( message.content.length > 0 && message.content.startsWith( discordPrefix ) )
        {
            var tmessage = message.content.substring(discordPrefix.length).trim();

            var args = splitArgs( tmessage );

            if ( args && args.length >= 1 )
            {
                var command = args.shift();
                var commandFunction = commands[command];
                if (!!commandFunction)
                {
                    commandFunction(message, args, tmessage);
                }
            }
        }
    });
                    
    var subs = new Subscriptions( discordChannels, players, kills, chunkHistory, pendingCommandList );

    //Alta Login
    //Sessions.loginWithHash(username, mpassword);
    const bot = new WebsocketBot();
    //Use a hashed password, SHA512
    await jsapi.Sessions.loginWithUsername(username, mpassword);
    await bot.loginWithHash(username, mpassword);
    while ( true ){
		try {
			console.log( "Checking "+ targetServer )
			var serverDetails = await Servers.getDetails( targetServer )
			//console.log( serverDetails )
			if ( typeof( serverDetails.online_ping ) === 'undefined' )
			{
				console.log( "Server is offline" )
				serverConnectedState = false
				if ( typeof( botConnection.wrapper ) != undefined && subscriptionsActive ) {
					console.log( "Removing subscriptions")
					botConnection.wrapper.emitter.removeAllListeners()
					subscriptionsActive = false;
				}
			} else {
				if ( !serverConnectedState )
				{                    
					console.log( "Server is online, connecting...")
					var details = await Servers.joinConsole( targetServer )
					if ( details.allowed )
					{
						//console.log( details )
						var connection = new Connection( details.name )
						connection.onClose = (data) => {
							try {
								console.log("Server disconnected");
								serverConnectedState = false;
								if ( typeof( botConnection.wrapper ) != undefined && subscriptionsActive ) {
                                    console.log( "Removing subscriptions");
                                    clearTimeout(Refresh);
                                    botConnection.wrapper.emitter.removeAllListeners();
									subscriptionsActive = false;
								}
							}
							catch( e ) {
								console.log("Error removing subscriptions, error: " + e.message);
							}
						};
						
						try
						{
							await connection.connect( details.connection.address, details.connection.websocket_port, details.token )
						} catch( e ) {
							console.log("Cannot connect to server, error: "+ e.message);
							await sleep( connectInterval )
							continue
						}
						serverConnectedState = true
						var wrapper = new BasicWrapper( connection )
						subs.SetWrapper( wrapper )

						botConnection = 
						{
							"connection" : connection,
							"wrapper" : wrapper
						}         

						console.log( ts() +"loading inital players" );
						for ( var i in serverDetails.online_players )
						{
							let oplayer = serverDetails.online_players[i];
							subs.PlayerJoined( discord, { "user": { "id": oplayer.id, "username": oplayer.username } });
                        }
                        const Refresh = setTimeout(() => {
                            botConnection.wrapper.send("save now");
                            console.log( "Removing subscriptions");
                            botConnection.wrapper.emitter.removeAllListeners();
                            subscriptionsActive = false;
                            // Subscriptions
                            subscribeTo( "InfoLog", data => { subs.InfoLog( discord, data ) } )
                            subscribeTo( "PlayerJoined", data => { subs.PlayerJoined( discord, data ) } )
                            subscribeTo( "PlayerLeft", data => { subs.PlayerLeft( discord, data ) } )
                            subscribeTo( "PlayerKilled", data => { subs.PlayerKilled( discord, data ) } )
                            subscribeTo( "TradeDeckUsed", data => { subs.TradeDeckUsed( discord, data ) } )
                            subscribeTo( "CreatureKilled", data => { subs.CreatureKilled( discord, data ) } )
                            subscribeTo( "PlayerStateChanged", data => { subs.PlayerStateChanged( discord, data ) } )
                            subscribeTo( "PlayerMovedChunk", data => { subs.PlayerMovedChunk( discord, data ) } )
                            subscribeTo( "TraceLog", data => {
                                if ( pendingCommandList.length && data.logger === pendingCommandList[0].module )
                                {
                                    console.log( "the command is a module match" )
                                    // TODO: add a 'type' to pending commands to better match response items
                                    let command = pendingCommandList.shift();
                                    if ( command )
                                    {
                                        console.log( "executing handler" )
                                        command.handler( data.message );
                                    }
                                }
                            });
                          }, RefreshSub);
					} else {
						console.log( "Server is not connectable")
						serverConnectedState = false
						console.log( connDetails)
					}
				} else {
					console.log( "Server is connected and alive")
				}
			}
            await sleep( serverPingInterval )
        }
		catch (e) {
			console.log("Critical error, exiting. " + e.message);
		}
    }
    // end bot.run()
}