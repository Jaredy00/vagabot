//Load required classes.
const { Sessions, Servers } = require('alta-jsapi');
const jsapi = require("alta-jsapi");
const jwtDecode = require('jwt-decode');
const { WebsocketBot } = require('att-bot-core');
const { BasicWrapper, Connection } = require('att-websockets');
const Discord = require('discord.js');
const {Client, RichEmbed} = require('discord.js');
const moment = require('moment');
const sha512 = require('crypto-js/sha512');
const fs = require('fs');
const Zone = require('./Zones');
const talkedRecently = new Set();

//Local classes
const Player = require('./src/player.js');
const Subscriptions = require('./src/subscriptions.js');

//Load information from credentials and config
const { username, password, botToken } = require("./credentials");
const { targetServer, showAllServers, discordPrefix, discordChannels, discordRoles } = require("./config");

//NeDB
var Datastore = require('nedb');
const { nextTick } = require('process');
var players = new Datastore({ filename : 'data/players.db', autoload: true });
var kills = new Datastore({ filename : 'data/playerkills.db', autoload: true });
var chunkHistory = new Datastore({ filename : 'data/chunkhistory.db', autoload: true });
players.ensureIndex({ fieldName: 'id', unique: 'true' });
players.persistence.setAutocompactionInterval( 129600 );

var connectInterval = 30000; // milliseconds
var serverPingInterval = 15000; // ms
var subscriptionConnectInterval = 10000; //ms
var RefreshSub = 300000; //ms
var Playerl = 1000; //ms
var serverConnectedState = false;
var subscriptionsActive = false;
var botConnection = {};
var pendingCommandList = [];

//Some utility helper functions and prototypes
function ts()
{ 
    return "["+ moment().format("YYYY/MM/DD HH:MM:SS") +"] " 
}

function strrep( str, n )
{
    if ( n < 1 ) return '';
    var result = str;
    while( n-- > 0 )
    {
        result += str;
    }
    return result;
}

function convertPassToHash( username, password, botToken )
{
    // The SHA512 hash generated by crypto-js/sha512 will be 128 characters
    if ( password.length !== 128 )
    {
        console.log( "Plaintext password encountered, converting to SHA512 hash for permanent storage" );
        newPass = sha512( password ).toString();
        newFile = { "username" : username, "password" : newPass, "botToken": botToken };
        fs.writeFile('./credentials.json', JSON.stringify( newFile, null, 4 ), function( err ) {
            if ( err )
            {
                console.log( err );
            } else {
                console.log( "New credentials.json saved" );
            }
        });
        password = newPass;
    }
    return password;
}

function updateHandler( err, rows )
{
    if ( err ) { console.log( err ); }
}

//Command list
const commands = {
    'Ping': (message) =>
    {
        message.channel.send("pong");
    },
    'Where': (message, args) =>
    {
        while ( args.length && args[0].toLowerCase() === "is" )
        {
            argv = args.shift();
        }

        var username = args.join(' ');
        players.findOne({ username: username }, function( err, player ) {
            if ( err )
            {
                console.log( err );
            } else if ( !!player && player.lastChunk !== undefined ) {
                message.channel.send( '```'+ username +" was last seen at "+ player.lastChunk +'```');
            } else {
                message.channel.send( '```'+ "No location known for "+ username +'```' );
            }
        });
    },
    'Player' : async function ( message, args )
    {
        switch( args.shift() )
        {
            case 'Path':
                // Return known history of player movements
                var username = args.join(' ');
                players.findOne({ username: username }, function( err, player ) {
                    if ( err ) 
                    {
                        message.channel.send('```'+ "No player data found for "+ username +'```');
                    } else {
                        if ( !!player )
                        {
                            chunkHistory.find({ player: player.id }).sort({ ts: -1 }).exec( function ( err, chunklist ) {
                                if ( err )
                                {
                                    console.log( err );
                                } else if ( !!chunklist ) {
                                    let limit = 20;
                                    var response  = '| Path History for '+ username +"\n";
                                        response += '|------------------'+ strrep('-', username.length+1) +"\n";
                                    if ( chunklist.length < limit ) { limit = chunklist.length; }
                                    for ( var i = 0; i < limit ; i++ ) {
                                        var elem = chunklist[i];
                                        response += "|["+ moment( elem.ts ).format( "YYYY/MM/DD HH:mm:ss" ) +"] "+ elem.chunk +"\n";
                                    }
                                    message.channel.send('```'+ response +'```');
                                } else {
                                    message.channel.send('```'+ "No path data found for "+ username +'```');
                                }
                            });
                        } else {
                            message.channel.send('```'+ "No player found for "+ username +'```');
                        }
                    }
                });
            break;
            
        }
    },
    'Players': async function (message, args)
    {
        var servers = await Servers.getOnline();
        var listTable = '';

        while ( args.length && ( args[0].toLowerCase() === "online" || args[0].toLowerCase() === "in" || args[0].toLowerCase() === "on" ) )
        {
            args.shift();
        }

        var mustMatch = args.join(' ');

        for( var i in servers )
        {
            var pOnline = servers[i].online_players;
            if ( pOnline.length <= 0 && !mustMatch ) 
            {
                continue
            }

            if ( !showAllServers && !targetServer.includes( servers[i].id ) )
            {
                continue;
            }
            
            if ( mustMatch )
            {
                var re = new RegExp( mustMatch, 'ig' );
                if ( !servers[i].name.match( re ) )
                {
                    continue;
                }
            }
                       
            listTable += "| "+ servers[i].name + "\n";
            listTable += "|"+ strrep('-', (servers[i].name.length + 1)) +"\n";     

            if ( pOnline.length <= 0 )
            {
                listTable += "| No players online\n"
            } else {
                for( var n in pOnline )
                {
                    listTable += "| "+ pOnline[n].username +"\n";
                }
            }

            listTable += "\n";
        }

        if ( listTable === '' )
        {
            if ( mustMatch )
            {
                message.channel.send('```No server found matching "'+ mustMatch +'"```');
            } else {
                message.channel.send('```No players were found online```');
            }
        } else {
            message.channel.send('```'+ listTable +'```');
        }
    },
    'Zone': async function (message, args)
    {
        switch( args.shift() )
        {
            case 'History':
                var chunkName = args.join(' ');
                players.find({}, function( err, playerList ) {
                    chunkHistory.find({ chunk: chunkName }).sort({ ts: -1 }).exec( function( err, chunklist ) {
                        if ( err )
                        {
                            console.log( err );
                        } else if ( !chunklist ) {
                            message.channel.send('```'+ "No history for zone '"+ chunkName +"'"+ '```');
                        } else {
                            var response  = "| Players who have recently visited zone '"+ chunkName +"'\n";
                                response += "|--------------------------------"+ strrep( '-', chunkName.length ) +"-\n";
                            let limit = 1500;
                            if ( chunklist.length < limit ) { limit = chunklist.length; }
                            for ( var i = 0; i < limit; i++ ) {
                                ichunk = chunklist[i];
                                if ( ++i > 10 ) { }
                                player = playerList.find( x => x.id === ichunk.player );
                                response += "|["+ moment( ichunk.ts ).format("YYYY/MM/DD HH:mm:ss") +"] "+ player.username +"\n";
                                if ( response.length > 1900 ) {
                                    message.channel.send('```'+ response +'```');
                                    response = "|--------------------------------"+ strrep( '-', chunkName.length ) +"-\n";
                                }                        
                            };
                            message.channel.send('```'+ response +'```');   
                        }
                    });
                });
            break;
        }
    },
    'Playermessage': (message, args) =>
    {
        if ( message.member.roles.some( x => discordRoles.admin.includes( x.id ) )){
        //args[0] = player
        //args[1] = message
        //args[2] = seconds
        botConnection.wrapper.send("player message " + args[0] + " " + "'" + args[1] + "'" + " " + args[2]);
        message.channel.send( '```'+ "Message Sent" +'```' );
        }else{
            message.channel.send( '```'+ "No" +'```' );
        }
    },
    'Help': (message) =>
    {
        if ( message.member.roles.some( x => discordRoles.admin.includes( x.id ) )){
            const Embed = new RichEmbed()
            .setColor('#00FF00')
            .setTitle('Commands')
            .addField('!Ping', 'Replies with pong to indicate bot is online', false )
            .addField('!Where (playername)', 'Replies with the current location of a player', false )
            .addField('!Player Path (playername)', 'Replies with a list of every chunk the player has entered', false )
            .addField('!Players', 'Replies with current online server', false )
            .addField('!Zone History (Chunk)', 'Replies with a list of every player to enter the chunk', false )
            .addField('!Coinbank (playername)', 'Checks the current balance of the players current ingame ATM coin count', false )
            .addField('!Playermessage (playername) (Message in quotes) (seconds)', 'Sends an ingame message to a player', false )
            .addField('!Verify (Token)', 'Links your Discord to your Ingame account using the Alta token(Same method as TownCrier)', false )
            .addField('!Transfer (Discord or ATT)', 'Transfers your atm coin balance back and forth between discord and the server Requires you to link your accounts with !link', false )
            .addField('!Balance (@Player)', 'Leave (@Player) blank to see your own balance or ping a player to see that players balance, Only works if the player has their account linked', false )
            .addField('!Pay (@Player) (Amount to send)', 'Send gold coins to other players over discord, Requires both you and the receiver to have linked their accounts', false )
            .addField('!Roll (Odd or Even) (Amount to Bed)', 'You gamble your money the dice will roll and odd or even number if you win you gain whatever you bet if you lose you lose whatever you bet you cant bet what you dont have, Requires you to link your accounts with !link, This command has a 3 minute cooldown', false )
            .addField('!Help', 'Replies with a list of commands', false )
            message.channel.send(Embed);
        }else{
            const Embed = new RichEmbed()
            .setColor('#00FF00')
            .setTitle('Commands')
            .addField('!Ping', 'Replies with pong to indicate bot is online', false )
            .addField('!Where (playername)', 'Replies with the current location of a player', false )
            .addField('!Players', 'Replies with current online server', false )
            .addField('!Verify (Token)', 'Links your Discord to your Ingame account using the Alta token(Same method as TownCrier)', false )
            .addField('!Transfer (Discord or ATT)', 'Transfers your atm coin balance back and forth between discord and the server Requires you to link your accounts with !link', false )
            .addField('!Balance', 'Replies with both your balance on the server and in discord, Requires you to link your accounts with !link', false )
            .addField('!Pay (@Player) (Amount to send)', 'Send gold coins to other players over discord, Requires both you and the receiver to have linked their accounts', false )
            .addField('!Roll (Odd or Even) (Amount to Bed)', 'You gamble your money the dice will roll and odd or even number if you win you gain whatever you bet if you lose you lose whatever you bet you cant bet what you dont have, Requires you to link your accounts with !link, This command has a 3 minute cooldown', false )
            .addField('!Help', 'Replies with a list of commands', false )
            message.channel.send(Embed);
        }
    },
    'Verify': async function (message, args)
    {
        let key = args[0]
        try{
        await jsapi.Users.getVerified(key);
            let result = jwtDecode(key)
            user = message.author.username + "#" + message.author.discriminator;
            if(result.user_data.includes(user)){
                let discordID = message.author.id
                let attID = Number(result.UserId)
                players.findOne({ id: attID }, function(err, docs) {
                    if(docs){
                        if(!docs.Discord){
                            players.update(
                                { id: attID }, 
                                { $set: { Discord: discordID, Balance: 0 } },
                                { upsert: true },
                                updateHandler,
                            );
                            message.delete().catch();
                            message.channel.send("Account " + user + " linked with " + docs.username);
                        }else{
                            message.channel.send('```' + "Account is already Linked" + '```');
                        }
                    }else{
                        message.channel.send('```' + "Their are no records of your att account" + '```');
                    }
                });
            }else{
                message.channel.send("Your Linking the wrong account");
            }
        }catch {
            message.channel.send('```' + "Invalid Token" + '```');
        }
    },
    'Transfer': (message, args) =>
    {
        const User = message.author.id
        players.findOne({ Discord: User }, async function(err, docs) {
            if (err) throw err;
            if (docs){
                var serverDetails = await Servers.getDetails( targetServer )
                const isOnline = (player) => serverDetails.online_players.some(({ username }) => username === player); 
                if(isOnline(docs.username)){
                    if(args[0] === "Discord"){
                        botConnection.wrapper.send("trade atm get " + docs.id).then(Response=>{
                            players.findOne({ Discord: User }, function(err, docs) {
                                if(docs.Balance){
                                    var NewBal = Number(Response.Result) + Number(docs.Balance)
                                    players.update(
                                        { Discord: User }, 
                                        { $set: { Balance: NewBal, Bank: 0 } },
                                        { upsert: true },
                                        updateHandler,
                                    );
                                    botConnection.wrapper.send("trade atm set " + docs.id + " 0")
                                    message.channel.send('```' + "Your gold has now been transferred to discord and your discord balance is " + NewBal + '```');
                                }else{
                                    players.update(
                                        { Discord: User }, 
                                        { $set: { Balance: Number(Response.Result), Bank: 0 } },
                                        { upsert: true },
                                        updateHandler,
                                    );
                                    botConnection.wrapper.send("trade atm set " + docs.id + " 0")
                                    message.channel.send('```' + "Your gold has now been transferred to discord and your discord balance is " + Response.Result + '```'); 
                                }
                            });
                        })
                    }
                    if(args[0] === "ATT"){
                        players.findOne({ Discord: User }, function(err, docs) {
                            if(docs.Balance){
                                botConnection.wrapper.send("trade atm add " + docs.id + " " + docs.Balance)
                                players.update(
                                    { Discord: User }, 
                                    { $set: { Balance: 0 } },
                                    { upsert: true },
                                    updateHandler,
                                ); 
                                botConnection.wrapper.send("trade atm get " + docs.id).then(Response=>{
                                    message.channel.send('```' + "Your gold has now been transferred to the server and your new balance is " + Response.Result + '```');
                                })
                            }
                        });
                    }
                }else{
                    message.channel.send('```' + "You are not online, Please join the server and Try again" + '```');
                }
            }else{
                message.channel.send('```' + "Please connect your account using !Verify" + '```');
            }
        });
    },
    'Balance': (message, args) =>
    {
        if ( message.member.roles.some( x => discordRoles.admin.includes( x.id ) )){
            if(!args[0]){
                const User = message.author.id
                players.findOne({ Discord: User }, function(err, docs) {
                    if (err) throw err;
                    if (docs){
                        if(docs.Discord){
                            if(docs.Balance){
                                const Embed = new RichEmbed()
                                .setColor('#00FF00')
                                .setTitle(docs.username)
                                .addField('Server Balance', docs.Bank, true )
                                .addField('Discord Balance', docs.Balance, true )
                                message.channel.send(Embed);
                            }else{
                                players.update(
                                    { Discord: User }, 
                                    { $set: { Balance: 0 } },
                                    { upsert: true },
                                    updateHandler,
                                );
                                const Embed = new RichEmbed()
                                .setColor('#00FF00')
                                .setTitle(docs.username)
                                .addField('Server Balance', docs.Bank, true )
                                .addField('Discord Balance', '0', true )
                                message.channel.send(Embed);
                            }
                        }else{
                            message.channel.send('```' + "Please connect your account using !Verify" + '```');
                        }
                    }else{
                        message.channel.send('```' + "Their are no records of you or you haven't linked your account with !Verify" + '```');
                    }
                });
            }else if(args[0] == message.mentions.members.first()){
                const Player = message.mentions.members.first().id;
                players.findOne({ Discord: Player }, function(err, docs) {
                    if (err) throw err;
                    if (docs){
                        if(docs.Discord){
                            if(docs.Balance){
                                const Embed = new RichEmbed()
                                .setColor('#00FF00')
                                .setTitle(docs.username)
                                .addField('Server Balance', docs.Bank, true )
                                .addField('Discord Balance', docs.Balance, true )
                                message.channel.send(Embed);
                            }else{
                                players.update(
                                    { Discord: Player }, 
                                    { $set: { Balance: 0 } },
                                    { upsert: true },
                                    updateHandler,
                                );
                                const Embed = new RichEmbed()
                                .setColor('#00FF00')
                                .setTitle(docs.username)
                                .addField('Server Balance', docs.Bank, true )
                                .addField('Discord Balance', '0', true )
                                message.channel.send(Embed);
                            }
                        }else{
                            message.channel.send('```' + "They haven't linked their account using !Verify" + '```');
                        }
                    }else{
                        message.channel.send('```' + "Their are no records of this account or they haven't linked their account with !Verify" + '```');
                    }
                });

            }
        }else{
            const User = message.author.id
            players.findOne({ Discord: User }, function(err, docs) {
                if (err) throw err;
                if (docs){
                    if(docs.Discord){
                        if(docs.Balance){
                            const Embed = new RichEmbed()
                            .setColor('#00FF00')
                            .setTitle(docs.username)
                            .addField('Server Balance', docs.Bank, true )
                            .addField('Discord Balance', docs.Balance, true )
                            message.channel.send(Embed);
                        }else{
                            players.update(
                                { Discord: User }, 
                                { $set: { Balance: 0 } },
                                { upsert: true },
                                updateHandler,
                            );
                            const Embed = new RichEmbed()
                            .setColor('#00FF00')
                            .setTitle(docs.username)
                            .addField('Server Balance', docs.Bank, true )
                            .addField('Discord Balance', '0', true )
                            message.channel.send(Embed);
                        }
                    }else{
                        message.channel.send('```' + "Please connect your account using !Verify" + '```');
                    }
                }else{
                    message.channel.send('```' + "Their are no records of you or you haven't linked your account with !Verify" + '```');
                }
            });
        }
    },
    'Pay': (message, args) =>
    {
        const User = message.author.id
        const Recipient = message.mentions.members.first().id;
        players.findOne({ Discord: User }, function(err, docs) {
            if (err) throw err;
            if (docs){
                players.findOne({ Discord: User }, function(err, docs) {
                    if(docs.Balance){
                        players.findOne({ Discord: Recipient }, function(err, docs) {
                            if (err) throw err;
                            if (docs){
                                players.findOne({ Discord: User }, function(err, docs) {
                                    var NewBalself = docs.Balance - args[1]
                                    if(NewBalself >= 0){ 
                                        players.update(
                                            { Discord: User }, 
                                            { $set: { Balance: NewBalself } },
                                            { upsert: true },
                                            updateHandler,
                                        );
                                        players.findOne({ Discord: Recipient }, function(err, docs) {
                                            var NewBalRecp = Number(docs.Balance) + Number(args[1])
                                            players.update(
                                                { Discord: Recipient }, 
                                                { $set: { Balance: NewBalRecp } },
                                                { upsert: true },
                                                updateHandler,
                                            );
                                            message.channel.send( "You have sent " + args[1] + " gold coins to " + docs.username);
                                        });
                                    }else{
                                        //Not Enough Money
                                        message.channel.send('```' + "You're trying to send money you don't have" + '```');
                                    }
                                });
                            }else{
                                //Recipient account is not linked
                                message.channel.send('```' + "Their are no records of your Recipient or they have not linked their account yet" + '```');
                            }
                        });
                    }else{
                        //You Have No Balance
                        message.channel.send('```' + "Your Balance is 0" + '```');
                        players.update(
                            { Discord: User }, 
                            { $set: { Balance: 0 } },
                            { upsert: true },
                            updateHandler,
                        );
                    }
                });
            }else{
                //Link Your Account
                message.channel.send('```' + "Their are no records of you or you haven't linked your account with !Verify" + '```');
            }
        });
    },
    'Roll': (message, args) =>
    {
        const User = message.author.id
        players.findOne({ Discord: User }, function(err, docs) {
            if(docs){
                if(docs.Balance || Number(docs.Balance) == 0){
                    if(Number(docs.Balance) >= args[1]){
                        if(args[1] <= 65){
                            if (talkedRecently.has(message.author.id)) {
                                message.channel.send("Wait 3 minute before getting typing this again. - " + message.author);
                            }else{
                                if(args[0] == "Odd"){
                                    var Dice = ["1","2","2","3","4","4","5","6","6"]
                                    let random = Math.floor(Math.random() * 9);
                                    let Num = Dice[random]
                                    var Even = ["2","4","6"]
                                    var Odd = ["1","3","5"]
                                    if(Odd.includes(Num)){
                                        var NewBal = Number(docs.Balance) + Number(args[1])
                                        players.update(
                                            { Discord: User }, 
                                            { $set: { Balance: NewBal } },
                                            { upsert: true },
                                            updateHandler,
                                        );
                                        message.channel.send('```' + "You guested right the number was " + Num + "(Odd) You win" + '```');
                                    }
                                    if(Even.includes(Num)){
                                        var NewBal = Number(docs.Balance) - Number(args[1])
                                        players.update(
                                            { Discord: User }, 
                                            { $set: { Balance: NewBal } },
                                            { upsert: true },
                                            updateHandler,
                                        );
                                        message.channel.send('```' + "You guested wrong the number was " + Num + "(Even) You lose" + '```');
                                    }
                                }else if(args[0] == "Even"){
                                    var Dice = ["1","1","2","3","3","4","5","5","6"]
                                    let random = Math.floor(Math.random() * 9);
                                    let Num = Dice[random]
                                    var Even = ["2","4","6"]
                                    var Odd = ["1","3","5"]
                                    if(Even.includes(Num)){
                                        var NewBal = Number(docs.Balance) + Number(args[1])
                                        players.update(
                                            { Discord: User }, 
                                            { $set: { Balance: NewBal } },
                                            { upsert: true },
                                            updateHandler,
                                        );
                                        message.channel.send('```' + "You guested right the number was " + Num + "(Even) You win" + '```');
                                    }
                                    if(Odd.includes(Num)){
                                        var NewBal = Number(docs.Balance) - Number(args[1])
                                        players.update(
                                            { Discord: User }, 
                                            { $set: { Balance: NewBal } },
                                            { upsert: true },
                                            updateHandler,
                                        );
                                        message.channel.send('```' + "You guested Wrong the number was " + Num + "(Odd) You lose" + '```');
                                    }
                                }else{
                                    message.channel.send('```' + "pick Odd or Even" + '```');
                                }
                                            // Adds the user to the set so that they can't talk for a minute
                                talkedRecently.add(message.author.id);
                                setTimeout(() => {
                                // Removes the user from the set after a minute
                                talkedRecently.delete(message.author.id);
                                }, 180000);
                            }
                        }else{
                            message.channel.send('```' + "You tried to bet too much the max is 65" + '```');
                        }
                    }else{
                        message.channel.send('```' + "You do not have enough money" + '```');
                    }
                    
                }else{
                    message.channel.send('```' + "you haven't linked your account with !Verify" + '```');
                }
            }else{
                message.channel.send('```' + "Their are no records of you or you haven't linked your account with !Verify" + '```');
            }
        });

    },
    'STOP': (message, args) =>
    {
        if ( message.member.roles.some( x => discordRoles.admin.includes( x.id ) )){
            if(end){
                //Code never makes it here
                //Crashes bot on purpose
            }
        }
    },
}

function splitArgs( args )
{
    let spaceChars = '#s#';
    // If an exact match of the space character exists in the string, make it more unique
    while( args.indexOf( spaceChars ) > -1 ) { spaceChars += '|'; }

    // replace spaces which are inside quotes with the spaceChar placeholder
    let mangleargs = args.replace( /[“"]([^“^"]*)[“"]?/g, ( match, cap ) => {
        return cap.replace(/\s/g, spaceChars );
    });

    // split the padded string on actual spaces
    let newargs = mangleargs.split( /\ +/ );

    // replace the spaceChar in any matching elements with actual spaces
    let reg = new RegExp( spaceChars, 'g' );
    let argarr = newargs.map( ( x ) => { return x.replace( reg, ' ' ); });

    return argarr;
}

async function sleep( ms )
{
    await new Promise( resolve => setTimeout( resolve, ms ))
}

async function subscribeTo( subscription, callback )
{
    if ( serverConnectedState && ( typeof( botConnection.wrapper ) !== undefined ) )
    {        
        let state = await botConnection.wrapper.subscribe( subscription, callback )
        if (( typeof( state.Result ) == undefined ) || state.Result != 'Success' )
        {
            botConnection.wrapper.unsubscribe( subscription, callback )
            console.log( "Subscription to "+ subscription +" failed: ", state )
            setTimeout( function() { subscribeTo( subscription, callback ) }, subscriptionConnectInterval )
        } else {
            subscriptionsActive = true;
        }
    }
}

//Run the program
main();

async function main()
{
    console.log( ts() + "bot is starting" );

    // Convert the password to a hash if necessary
    var mpassword = convertPassToHash( username, password, botToken );
    // Players in database
    //players.find({}).exec( function( err, docs ) { console.log( docs ); });

    //Connect to discord
    const discord = new Discord.Client({
        disableEveryone: true,
        messageCacheMaxSize: 150,
        messageCacheLifetime: 240,
        messageSweepInterval: 300,
      });
    await new Promise( resolve =>
    {
        discord.on('ready', resolve);
        discord.login(botToken);
    });
    //Discord command and message management (todo: move to own lib)
    discord.on('message', message =>
    {
        if ( message.content.length > 0 && message.content.startsWith( discordPrefix ) )
        {
            var tmessage = message.content.substring(discordPrefix.length).trim();

            var args = splitArgs( tmessage );

            if ( args && args.length >= 1 )
            {
                var command = args.shift();
                var commandFunction = commands[command];
                if (!!commandFunction)
                {
                    commandFunction(message, args, tmessage);
                }
            }
        }
    });
                    
    var subs = new Subscriptions( discordChannels, players, kills, chunkHistory, pendingCommandList );

    //Alta Login
    //Sessions.loginWithHash(username, mpassword);
    const bot = new WebsocketBot();
    //Use a hashed password, SHA512
    await jsapi.Sessions.loginWithUsername(username, mpassword);
    await bot.loginWithHash(username, mpassword);
    while ( true ){
		try {
			console.log( "Checking "+ targetServer )
			var serverDetails = await Servers.getDetails( targetServer )
			//console.log( serverDetails )
			if ( typeof( serverDetails.online_ping ) === 'undefined' )
			{
				console.log( "Server is offline" )
				serverConnectedState = false
				if ( typeof( botConnection.wrapper ) != undefined && subscriptionsActive ) {
					console.log( "Removing subscriptions")
					botConnection.wrapper.emitter.removeAllListeners()
					subscriptionsActive = false;
				}
			} else {
				if ( !serverConnectedState )
				{                    
					console.log( "Server is online, connecting...")
					var details = await Servers.joinConsole( targetServer )
					if ( details.allowed )
					{
						//console.log( details )
						var connection = new Connection( details.name )
						connection.onClose = (data) => {
							try {
								console.log("Server disconnected");
								serverConnectedState = false;
								if ( typeof( botConnection.wrapper ) != undefined && subscriptionsActive ) {
                                    console.log( "Removing subscriptions");
                                    clearTimeout(Refresh);
                                    clearInterval(Playerloc);
                                    botConnection.wrapper.emitter.removeAllListeners();
									subscriptionsActive = false;
								}
							}
							catch( e ) {
								console.log("Error removing subscriptions, error: " + e.message);
							}
						};
						
						try
						{
							await connection.connect( details.connection.address, details.connection.websocket_port, details.token )
						} catch( e ) {
							console.log("Cannot connect to server, error: "+ e.message);
							await sleep( connectInterval )
							continue
						}
						serverConnectedState = true
						var wrapper = new BasicWrapper( connection )
						subs.SetWrapper( wrapper )

						botConnection = 
						{
							"connection" : connection,
							"wrapper" : wrapper
						}         

						console.log( ts() +"loading inital players" );
						for ( var i in serverDetails.online_players )
						{
							let oplayer = serverDetails.online_players[i];
							subs.PlayerJoined( discord, { "user": { "id": oplayer.id, "username": oplayer.username } });
                        }
                        subscribeTo( "InfoLog", data => { subs.InfoLog( discord, data ) } )
                        subscribeTo( "PlayerJoined", data => { subs.PlayerJoined( discord, data ) } )
                        subscribeTo( "PlayerLeft", data => { subs.PlayerLeft( discord, data ) } )
                        subscribeTo( "PlayerKilled", data => { subs.PlayerKilled( discord, data ) } )
                        subscribeTo( "TradeDeckUsed", data => { subs.TradeDeckUsed( discord, data ) } )
                        subscribeTo( "CreatureKilled", data => { subs.CreatureKilled( discord, data ) } )
                        subscribeTo( "PlayerStateChanged", data => { subs.PlayerStateChanged( discord, data ) } )
                        subscribeTo( "PlayerMovedChunk", data => { subs.PlayerMovedChunk( discord, data ) } )
                        subscribeTo( "TrialStarted", data => { subs.TrialStarted( discord, data ) } )
                        subscribeTo( "TrialFinished", data => { subs.TrialFinished( discord, data ) } )
                        subscribeTo( "TraceLog", data => {
                            if ( pendingCommandList.length && data.logger === pendingCommandList[0].module )
                            {
                                console.log( "the command is a module match" )
                                // TODO: add a 'type' to pending commands to better match response items
                                let command = pendingCommandList.shift();
                                if ( command )
                                {
                                    console.log( "executing handler" )
                                    command.handler( data.message );
                                }
                            }
                        });
                        const Refresh = setTimeout(() => {
                            botConnection.wrapper.send("save now");
                            console.log( "Removing subscriptions");
                            botConnection.wrapper.emitter.removeAllListeners();
                            subscriptionsActive = false;
                            // Subscriptions
                            subscribeTo( "InfoLog", data => { subs.InfoLog( discord, data ) } )
                            subscribeTo( "PlayerJoined", data => { subs.PlayerJoined( discord, data ) } )
                            subscribeTo( "PlayerLeft", data => { subs.PlayerLeft( discord, data ) } )
                            subscribeTo( "PlayerKilled", data => { subs.PlayerKilled( discord, data ) } )
                            subscribeTo( "TradeDeckUsed", data => { subs.TradeDeckUsed( discord, data ) } )
                            subscribeTo( "CreatureKilled", data => { subs.CreatureKilled( discord, data ) } )
                            subscribeTo( "PlayerStateChanged", data => { subs.PlayerStateChanged( discord, data ) } )
                            subscribeTo( "PlayerMovedChunk", data => { subs.PlayerMovedChunk( discord, data ) } )
                            subscribeTo( "TraceLog", data => {
                                if ( pendingCommandList.length && data.logger === pendingCommandList[0].module )
                                {
                                    console.log( "the command is a module match" )
                                    // TODO: add a 'type' to pending commands to better match response items
                                    let command = pendingCommandList.shift();
                                    if ( command )
                                    {
                                        console.log( "executing handler" )
                                        command.handler( data.message );
                                    }
                                }
                            });
                        }, RefreshSub);

                        const Playerloc = setInterval(() => {
                        for ( var i in serverDetails.online_players )
                        {
                            let oplayer = serverDetails.online_players[i];
                            botConnection.wrapper.send("player detailed " + oplayer.id).then(response =>{
                                const area = ["Zone1", "Zone2", "Zone3"]
                                area.forEach(a => {
                                    const regex = /\((-*\d+.*\d*), (-*\d+.*\d*), (-*\d+.*\d*)\)/;
                                    [_, x, y, z] = response.Result.Position.match(regex);
                                    let allowed = Zone[a].access
                                    let realminx = Number(Zone[a].minx)
                                    let realminz = Number(Zone[a].minz)
                                    let realmaxx = Number(Zone[a].maxx)
                                    let realmaxz = Number(Zone[a].maxz)
                                    if (realminx <= x && x <= realmaxx && realminz <= z && z <= realmaxz && !allowed.includes(Number(oplayer.id))) {
                                        console.log('x and z are a match');
                                        botConnection.wrapper.send(`Player teleport '${oplayer.id}' RespawnPoint`);
                                        botConnection.wrapper.send(`Player message '${oplayer.id}' "You entered restricted area" 5`);
                                    }
                                });
                            })
                        }
                        }, 1000);
					} else {
						console.log( "Server is not connectable")
						serverConnectedState = false
						console.log( connDetails)
					}
				} else {
					console.log( "Server is connected and alive")
				}
			}
            await sleep( serverPingInterval )
        
        }
		catch (e) {
			console.log("Critical error, exiting. " + e.message);
		}
    }
    // end bot.run()
}